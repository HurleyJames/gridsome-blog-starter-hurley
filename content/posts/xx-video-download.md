---
title: XXX视频下载折腾总结
date: 2020-01-05T21:00:00+08:00
published: true
slug: xx-video-download
tags:
- shell
- Chrome extension
- media
cover_image: "./images/xx-video-download.png"
canonical_url: false
description: 不怕XX耍流氓，就怕XX有文化
---

:::note ℹ️ Introduction

随着马上就要成为一名社畜，也意味着马上就会拥有一个自己的小家（租的）。因此，折腾狂的我不禁就想把一切能想到的配置都给配上。虽然暂时没钱配群辉NAS，但是作为一名司机，如何离线的、流畅地观看视频也是一项必备技能！在国外时，我最常访问的视频网站，除了Netflix就是XX了。然而，国内网络环境的限制，导致即使你有了梯子，速度也不尽如人意，总不能动手的同时，眼睛却得盯着进度条转圈圈吧？赶紧动手下载下来！

:::

## 前提

### 科学上网

这个我相信大家能有自己的办法解决，请相信，我们一切所做的都是合理、合法的行为。

### XX网站

作为成年人，我相信大家都会有自己的选择。很多网站在全球都是浏览量排名前10的网站了，那么，你又有什么理由不能去知道并访问呢？

## 工具

作为一个非常喜欢收集工具的人，我接触过很多下载类的工具，目前电脑里还留存的有：

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20210105193857.png)

### 迅雷

迅雷自然不必多言，可能已经陪伴了我们十多年。许多年前，装机工具有必备的软件肯定有它。它也的确是下载磁力链接的很好的选择。然而，随着非VIP用户的限速，它的下载速度在今天这个随便某个视频大小都过GB的今天，实在是令人难以满意。

如果您是一个小白用户，我认为迅雷仍然是最适合您的选择。只不过，对于XXX网站，迅雷显然是帮不上一点忙的。

:::note 💡 Tips

Mac端的迅雷应用应该相比Windows端的广告要少很多，Windows端的迅雷广告内容低劣，令人不堪其扰。

:::

### 百度网盘

曾今，它的名字还叫「百度云」。或许是为了给更加繁荣的百度云计算让位，它改名成了如今的百度网盘。一同更改的，还有它那非SVip用户的限速机制。

曾今，我经常是通过百度贴吧里搜索关键字，加入相关的百度云群组，根据群组中「好心人」分享的内容，保存进自己的网盘，然后下载观看。但这个方法在多年后的今天早已失效。且不说百度网盘严格的封禁机制（即使存储正常的学习内容，仍然有被乱封的风险）以及十几kb/s的普通用户下载速度，就连百度贴吧也早已风头不如当年，沦为一个广告遍地的社区。没有了核心的用户、有价值的内容，即使有着数百M的光纤，又有何用？

:::note 💡 Tips

其实我是认同百度网盘会员能够正常速度甚至加快速度下载文件的策略的。毕竟网盘不是免费的，如果人人都能够无限大容量的云存储空间以及满血的下载速度，那么其耗费以及占用带宽都是巨大的。最近，Google Drive也开始了付费空间，就说明这其实是市场正常化的趋势。「人是不可能一直薅羊毛的。」

:::

### IDM

### Motrix

### Downie

## 视频格式

尽管有了上面那些著名的下载软件，但是XX网站既然不提供下载按钮，就说明是不会轻易地让用户下载视频的。所以，我们并不能简单地通过视频播放的地址来下载。除此之外，通过查询资料才发现，XX网站的视频格式并不是我们日常常用的`.mp4`或者`.avi`等格式，而是**HLS**。

### HLS

HLS(Http Live Streaming)，是由Apple公司定义的用于实时流传输的协议。HLS基于HTTP协议实现，传输内容包括两部分：

* m3u8描述文件
* ts媒体文件

#### m3u8

m3u8用文本方式对媒体文件进行描述，由一系列标签组成。例如，其格式如下：

```
#EXTM3U
#EXT-X-TARGETDURATION:5
#EXTINF:5,
./0.ts
#EXTINF:5,
./1.ts
```

稍微解释一下这个文本格式的意思。#EXTM3U`这个是每个m3u8文件的第一行，必须是这个tag。`#EXT-X-TARGETDURATION`就很明显了，duration指定最大的媒体段时间长度（秒）。`#EXTINF`中指定的时间长度必须小于或者等于这个最大值。`#EXTINF`是描述单个媒体文件的长度，后面跟着的就是媒体文件。

#### ts

ts文件是传输流文件，视频编码格式主要是h264/mpeg4，音频格式为acc/MP3。

ts文件分为三层：

* ts(Transport Stream)层：在pes层上，加入了数据流的识别和传输必须的信息
* pes(Packet Elemental Stream)层：在音视频数据上加了时间戳等对数据帧的说明信息
* es(Elementray Stream)层：音视频数据

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/27100307_wUox.png)

### 获得m3u8和ts

我们已经了解到XX网站是通过m3u8文件和ts文件来播放视频的。m3u8实际上是一个可以用文本打开的文件，前面提到，它包含了和视频相关的标签，通过这些标签，可以获取到要下载的ts片段。下载下来的ts片段都是可以单独播放的，所以，我们最后将所有的ts片段合并成mp4文件就可以了。

理顺了整个实现思路，现在我们就需要找到XX网站的m3u8文件和ts文件。通过搜索引擎查询，我们发现可以使用浏览器就能完成。

1. 打开浏览器，打开要播放视频的网址；
2. 右键 -> 检查（或者按F12或者fn+F12）-> 点击Network
3. 点击播放视频
4. 点击滤斗的图标，即Filter，输入`m3u8`，即可找出m3u8文件
5. 除此之外，还可以看到很多ts文件

不幸的是，XX网站不愧是视频网站的「大牛」。我们通过如上的方法，只能看到一堆堆ts文件不断冒出来，然后m3u8文件是如何也搜不到。没有m3u8文件，也就拿不到ts文件下载的list。怎么解决呢？

## 下载

我们决定从Github中找找相关的办法。通过搜索「XX」关键字，我们发现第一个出现的开源项目就有解决办法。它提供了一个Chrome插件，通过安装插件的方式来下载m3u8文件。

### Chrome Helper

这个插件的开源项目有两个主要分支，目前最新的分支是`3.x.x`，另外一个分支就是`master`。最开始，我认为应该使用`master`分支更为稳定，结果按照README.md的使用说明操作后，发现的确是将视频的m3u8文件下载下来了。然而不幸的是，它的格式并不与我们上面介绍的m3u8的格式一样。它的格式如下：

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20210105231827.png)

可以发现，这应该是Base64解密后的文本。通过复制后进行Base64加密，我们发现仍然是一大串的文本，仍然不是传统的m3u8格式。

那么，如果换成`3.x.x`分支再使用插件，下载下来的是一个`video-name.sh`的脚本文件，通过执行脚本文件，我们就可以调用aria2来多线程地下载视频。

这个脚本内容写得非常好，不仅解析了m3u8文件，生成ts文件的列表，调用aria2下载，最终还使用ffmpeg来将下载下来的ts文件合并成mp4文件。

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20210105232929.png)

### Bug

然而，这个插件仍然存在不少的bug。首先是会莫名的终止程序。尽管aria2是支持断点续传的，但是总是终止程序就需要我们时刻守在身边，当出现问题就重新运行脚本。通过定位位置，我更改了脚本，在出现了这个问题后，就会重新执行该脚本。结果，又出现了第二个问题：某些ts片段提示我们缺少`Referer`头文件，然而尽管查找了该仓库的issue问题，仍然无法解决这个问题。

我为此编写了一个脚本，即复制某些下载好的脚本，将其改名并复制成那些出现`Referer`问题的脚本。然而，这种「掩耳盗铃」的方式显然不是一种最佳的解决办法。

所以，这个插件的稳定性仍然有待考察。但我们的确实现了下载视频的目的。

## 脚本

尽管这个过程不太容易，但我不仅了解到了m3u8和ts这两种视频方式，aria2这种下载工具，还编写了一些基础的脚本，为此我也对用`js`、`python`、`shell`等语言来编写脚本产生了巨大的兴趣！希望可以用`AppleScript`来实现更多提高效率的Workflow！

在这里，我放上一些在这个下载过程中临时编写出的「救急」脚本：

**复制文件并且批量改名**：

```Shell
# 要复制的文件名
cpFileName=seg-900-v1-a1.ts
# 复制的起始文件名的index
firstNum=901
# 复制的最终文件名的index
lastNum=968
# 中间的拼接字段
str1=seg-
# 最后的拼接字段，包括文件后缀名
str2=-v1-a1.ts

while [ $firstNum -le $lastNum ]; do
	# cp 批量复制文件并改成有顺序的文件名
	cp -vf $cpFileName $str1$firstNum$str2
	# 循环加1，改名
	let i+=1
done
```

---

:::note 💡 Tips

后来发现了一个更好的网站，不仅支持更多的种类、搜索，也提供下载功能，下次争取编写一个脚本实现自动化！

:::